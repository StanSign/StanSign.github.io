---
title: 3)Swift - 클로저(Closure).03
tags: [Swift, iOS]
style: fill
color: info
description: @autoclosure, @escaping
---

이번에는 @autoclosure와 @escaping에 대해 알아보겠습니다.

### @autoclosure

autoclosure도 우선 용어 자체를 살펴보겠습니다.

자동-클로저?

이게 대체 뭘까요?

이번에는 정의를 살펴봅시다.

**인자로서 전달된 일반구문/함수를 클로저로서 감싸는 것**

아무래도 일반구문/함수를 자동으로 클로저로서 취급한다.. 라는 의미인 것 같네요.

아직도 이해가 잘 가지 않으니 예제를 살펴보겠습니다.

~~~
func foo(closure: @autoclosure () -> ()) {
    // Tasks
}
~~~

@autoclosure가 사용되는 위치도 잘 기억해주세요. 인자명 뒤 타입 정의 바로 앞에 위치해있습니다!

자 그래서 대체 이게 무슨말이냐..

**@autoclosure**를 사용하면 클로저 타입의 인자 **closure**는 클로저가 아닌 일밤구문/함수를 받아도 **클로저로서 처리**해줍니다.

우선 @autoclosure를 사용하지 않았을 때를 봅시다.

~~~
func foo(_ closure: () -> Void) {
    closure()
}
~~~

위 함수를 호출할 때 어떻게 호출할까요? 아래와 같이 호출합니다.
~~~
foo({ 
    print("Hi! I'm Closure")
})
~~~

이번엔 같은 함수에 @autoclosure를 사용해봅시다.

~~~
func foo(_ closure: @autoclosure () -> Void) {
    closure()
}
~~~
위 함수는 아래처럼 호출됩니다.
~~~
foo(print("Hi! I'm Closure"))
~~~

**{ ... }** 이 중괄호가 없어진 것을 볼 수 있죠.

클로저는 본인이 클로저임을 알리기 위해 중괄호가 무조건 필요합니다. @autoclosure는 클로저가 아닌 일반구문/함수를 중괄호로 감싼 역할을 해주는 것이죠.

단 유의할 점은 @autoclosure를 사용하기 위해서는 클로저의 인자가 없어야 합니다!

~~~
func foo(closure: @autoclosure (Int) -> Void) {
    closure()
}
~~~

위와 경우 **(Int) -> Void** 인자로 Int 타입이 들어가있죠?

따라서 오류가 납니다. 꼭 주의해주세요!

그렇다면 일반구문에 비해서 @autoclosure을 사용했을 때의 차이점은 무엇일까요?

일반구문은 원래 실행 순서가 되면 **즉시 실행**됩니다. 

지연을 준다고 하더라도 지연을 주는 함수가 즉시 실행되었기 때문에 뒤에 따라오는 다른 함수들이 지연되는 것이죠.

그런데 클로저는 즉시 실행되지 않습니다. 함수 안에서 **해당 인자가 사용될 때 실행**되죠.

결론적으로 @escaping은 일반구문을 클로저처럼 사용하고 싶을 때 유용한 기능입니다.

### @escaping

